'use strict';

const aoconnect = require('@permaweb/aoconnect');
const pLimit = require('p-limit');
const fs = require('node:fs');
const path = require('node:path');
const os = require('node:os');
const Arweave = require('arweave');
const Ardb = require('ardb');
const process = require('node:process');
const node_child_process = require('node:child_process');
const util = require('node:util');
const createFileTree = require('pretty-file-tree');
const chalk = require('chalk');
const node_url = require('node:url');
const createJITI = require('jiti');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

const pLimit__default = /*#__PURE__*/_interopDefaultCompat(pLimit);
const fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
const path__default = /*#__PURE__*/_interopDefaultCompat(path);
const os__default = /*#__PURE__*/_interopDefaultCompat(os);
const Arweave__default = /*#__PURE__*/_interopDefaultCompat(Arweave);
const Ardb__default = /*#__PURE__*/_interopDefaultCompat(Ardb);
const process__default = /*#__PURE__*/_interopDefaultCompat(process);
const util__default = /*#__PURE__*/_interopDefaultCompat(util);
const createFileTree__default = /*#__PURE__*/_interopDefaultCompat(createFileTree);
const chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);
const createJITI__default = /*#__PURE__*/_interopDefaultCompat(createJITI);

const arweave = Arweave__default.init({
  host: "arweave.net",
  port: 443,
  protocol: "https"
});
const ardb = new (Ardb__default?.default ?? Ardb__default)(arweave);
function isArweaveAddress(address) {
  return typeof address === "string" && /^[a-z0-9-_]{43}$/i.test(address);
}
async function sleep(delay = 3e3) {
  return new Promise((resolve, _) => setTimeout(resolve, delay));
}
async function retryWithDelay(fn, maxAttempts = 3, delay = 1e3) {
  let attempts = 0;
  const attempt = async () => {
    try {
      return await fn();
    } catch (error) {
      attempts += 1;
      if (attempts < maxAttempts) {
        return new Promise((resolve) => setTimeout(() => resolve(attempt()), delay));
      } else {
        throw error;
      }
    }
  };
  return attempt();
}

var __accessCheck$4 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$4 = (obj, member, getter) => {
  __accessCheck$4(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$4 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$4 = (obj, member, value, setter) => {
  __accessCheck$4(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod$4 = (obj, member, method) => {
  __accessCheck$4(obj, member, "access private method");
  return method;
};
var _jwk, _checkIfWalletLoaded, checkIfWalletLoaded_fn;
const _Wallet = class _Wallet {
  constructor(jwk) {
    __privateAdd$4(this, _checkIfWalletLoaded);
    __privateAdd$4(this, _jwk, void 0);
    __privateSet$4(this, _jwk, jwk);
  }
  /**
   * Check if the passed argument is a valid JSON Web Key (JWK) for Arweave.
   * @param obj - The object to check for JWK validity.
   * @returns {boolean} True if it's a valid Arweave JWK, otherwise false.
   */
  static isJwk(obj) {
    if (typeof obj !== "object") {
      return false;
    }
    const requiredKeys = ["n", "e", "d", "p", "q", "dp", "dq", "qi"];
    return requiredKeys.every((key) => key in obj);
  }
  static async getWallet(jwkOrPath) {
    try {
      if (!jwkOrPath) {
        throw new Error("Wallet not specified");
      }
      if (this.isJwk(jwkOrPath)) {
        return jwkOrPath;
      }
      const jwk = fs__default.readFileSync(jwkOrPath, "utf8");
      return JSON.parse(jwk);
    } catch (e) {
      if (fs__default.existsSync(path__default.resolve(`${os__default.homedir()}/.aos.json`))) {
        return JSON.parse(fs__default.readFileSync(path__default.resolve(`${os__default.homedir()}/.aos.json`), "utf-8"));
      }
      const wallet = await arweave.wallets.generate();
      fs__default.writeFileSync(path__default.resolve(`${os__default.homedir()}/.aos.json`), JSON.stringify(wallet));
      return wallet;
    }
  }
  static async load(jwkOrPath) {
    const jwk = await this.getWallet(jwkOrPath);
    return new _Wallet(jwk);
  }
  async getAddress() {
    __privateMethod$4(this, _checkIfWalletLoaded, checkIfWalletLoaded_fn).call(this);
    return await arweave.wallets.getAddress(__privateGet$4(this, _jwk));
  }
  get jwk() {
    __privateMethod$4(this, _checkIfWalletLoaded, checkIfWalletLoaded_fn).call(this);
    return __privateGet$4(this, _jwk);
  }
};
_jwk = new WeakMap();
_checkIfWalletLoaded = new WeakSet();
checkIfWalletLoaded_fn = function() {
  if (!__privateGet$4(this, _jwk)) {
    throw new Error("Wallet not loaded yet");
  }
};
let Wallet = _Wallet;

var __accessCheck$3 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$3 = (obj, member, getter) => {
  __accessCheck$3(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$3 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$3 = (obj, member, value, setter) => {
  __accessCheck$3(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod$3 = (obj, member, method) => {
  __accessCheck$3(obj, member, "access private method");
  return method;
};
var _instances, _name, _getInstance, getInstance_fn, _logMessage, logMessage_fn;
const _Logger = class _Logger {
  constructor(name) {
    __privateAdd$3(this, _logMessage);
    __privateAdd$3(this, _name, void 0);
    __privateSet$3(this, _name, name);
  }
  static init(name) {
    return __privateMethod$3(this, _getInstance, getInstance_fn).call(this, name);
  }
  log(message, prefixNewLine = false, suffixNewLine = false) {
    __privateMethod$3(this, _logMessage, logMessage_fn).call(this, `${chalk__default.blue(`[${__privateGet$3(this, _name)}]`)} ${message}`, prefixNewLine, suffixNewLine);
  }
  success(message, prefixNewLine = false, suffixNewLine = false) {
    __privateMethod$3(this, _logMessage, logMessage_fn).call(this, `${chalk__default.blue(`[${__privateGet$3(this, _name)}]`)} ${chalk__default.green(message)}`, prefixNewLine, suffixNewLine);
  }
  error(message, prefixNewLine = false, suffixNewLine = false) {
    __privateMethod$3(this, _logMessage, logMessage_fn).call(this, `${chalk__default.red(`[${__privateGet$3(this, _name)}]`)} ${chalk__default.red(message)}`, prefixNewLine, suffixNewLine);
  }
  static log(name, message, prefixNewLine = false, suffixNewLine = false) {
    __privateMethod$3(this, _getInstance, getInstance_fn).call(this, name).log(message, prefixNewLine, suffixNewLine);
  }
  static success(name, message, prefixNewLine = false, suffixNewLine = false) {
    __privateMethod$3(this, _getInstance, getInstance_fn).call(this, name).success(message, prefixNewLine, suffixNewLine);
  }
  static error(name, message, prefixNewLine = false, suffixNewLine = false) {
    __privateMethod$3(this, _getInstance, getInstance_fn).call(this, name).error(message, prefixNewLine, suffixNewLine);
  }
};
_instances = new WeakMap();
_name = new WeakMap();
_getInstance = new WeakSet();
getInstance_fn = function(name) {
  if (!__privateGet$3(_Logger, _instances).has(name)) {
    __privateGet$3(_Logger, _instances).set(name, new _Logger(name));
  }
  return __privateGet$3(_Logger, _instances).get(name);
};
_logMessage = new WeakSet();
logMessage_fn = function(message, prefixNewLine, suffixNewLine) {
  const prefix = prefixNewLine ? "\n" : "";
  const suffix = suffixNewLine ? "\n" : "";
  console.log(`${prefix}${message}${suffix}`);
};
__privateAdd$3(_Logger, _getInstance);
__privateAdd$3(_Logger, _instances, /* @__PURE__ */ new Map());
let Logger = _Logger;

var __accessCheck$2 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$2 = (obj, member, getter) => {
  __accessCheck$2(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$2 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$2 = (obj, member, value, setter) => {
  __accessCheck$2(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod$2 = (obj, member, method) => {
  __accessCheck$2(obj, member, "access private method");
  return method;
};
var _luaPath, _logger, _fileExists, fileExists_fn, _getModulePath, getModulePath_fn, _createExecutableFromProject, createExecutableFromProject_fn, _topologicalSort, topologicalSort_fn, _createProjectStructure, createProjectStructure_fn, _findRequires, findRequires_fn;
const execAsync = util__default.promisify(node_child_process.exec);
class LuaProjectLoader {
  constructor(name, luaPath) {
    __privateAdd$2(this, _fileExists);
    __privateAdd$2(this, _getModulePath);
    __privateAdd$2(this, _createExecutableFromProject);
    __privateAdd$2(this, _topologicalSort);
    __privateAdd$2(this, _createProjectStructure);
    __privateAdd$2(this, _findRequires);
    __privateAdd$2(this, _luaPath, void 0);
    __privateAdd$2(this, _logger, void 0);
    __privateSet$2(this, _luaPath, luaPath || "");
    __privateSet$2(this, _logger, Logger.init(name));
  }
  async loadContract(contractPath) {
    if (/\.lua$/.test(contractPath)) {
      let filePath = contractPath;
      if (!path__default.isAbsolute(filePath)) {
        filePath = path__default.resolve(path__default.join(process__default.cwd(), contractPath));
      }
      if (!await __privateMethod$2(this, _fileExists, fileExists_fn).call(this, filePath)) {
        throw new Error(chalk__default.red(`${filePath} file not found.`));
      }
      __privateGet$2(this, _logger).log(`Deploying: ${contractPath}`, false, true);
      let line = await fs.promises.readFile(filePath, "utf-8");
      __privateGet$2(this, _logger).log(`Parsing contract structure...`, false, true);
      const projectStructure = await __privateMethod$2(this, _createProjectStructure, createProjectStructure_fn).call(this, line, path__default.dirname(filePath));
      if (projectStructure.length > 0) {
        line = `${__privateMethod$2(this, _createExecutableFromProject, createExecutableFromProject_fn).call(this, projectStructure)}

${line}`;
        __privateGet$2(this, _logger).log(chalk__default.yellow(`The following files will be deployed:`), false, true);
        console.log(chalk__default.dim(createFileTree__default([...projectStructure.map((m) => m.path), `${filePath} ${chalk__default.reset(chalk__default.bgGreen(" MAIN "))}`])));
        console.log("");
      }
      return line.trim();
    } else {
      throw new Error(chalk__default.red("It requires a *.lua file"));
    }
  }
}
_luaPath = new WeakMap();
_logger = new WeakMap();
_fileExists = new WeakSet();
fileExists_fn = async function(path2) {
  try {
    await fs.promises.access(path2, fs.constants.F_OK | fs.constants.R_OK);
    return true;
  } catch {
    return false;
  }
};
_getModulePath = new WeakSet();
getModulePath_fn = async function(module, cwd) {
  try {
    const modPath = path__default.join(cwd, `${module.replace(/\./g, "/")}.lua`);
    if (await __privateMethod$2(this, _fileExists, fileExists_fn).call(this, modPath)) {
      return modPath;
    }
    const luaCode = `print(package.searchpath('${module}', package.path .. ';' .. '${__privateGet$2(this, _luaPath)}'))`;
    const command = `lua -e "${luaCode}"`;
    const { stdout, stderr } = await execAsync(command);
    if (stderr) {
      return;
    }
    if (stdout) {
      const potentialPath = stdout.trim();
      if (await __privateMethod$2(this, _fileExists, fileExists_fn).call(this, potentialPath)) {
        return potentialPath;
      }
    }
  } catch (error) {
  }
};
_createExecutableFromProject = new WeakSet();
createExecutableFromProject_fn = function(project) {
  const getModFnName = (name) => name.replace(/\./g, "_").replace(/^_/, "");
  const contents = [];
  for (const mod of project) {
    const existing = contents.find((m) => m.path === mod.path);
    const moduleContent = !existing && `-- module: "${mod.name}"
local function _loaded_mod_${getModFnName(mod.name)}()
${mod.content}
end
` || "";
    const requireMapper = `
_G.package.loaded["${mod.name}"] = _loaded_mod_${getModFnName(existing?.name || mod.name)}()`;
    contents.push({
      name: mod.name,
      path: mod.path,
      code: moduleContent + requireMapper
    });
  }
  return contents.reduce((acc, con) => `${acc}

${con.code}`, "");
};
_topologicalSort = new WeakSet();
topologicalSort_fn = function(moduleMap) {
  const visited = /* @__PURE__ */ new Set();
  const result = [];
  function visit(modName) {
    if (visited.has(modName)) {
      return;
    }
    const mod = moduleMap.get(modName);
    if (!mod) {
      throw new Error(`Module ${modName} is not found in the module map.`);
    }
    visited.add(modName);
    mod.dependencies?.forEach((depName) => visit(depName));
    result.push(mod);
  }
  moduleMap.forEach((_, modName) => visit(modName));
  return result;
};
_createProjectStructure = new WeakSet();
createProjectStructure_fn = async function(mainFile, cwd) {
  const modules = await __privateMethod$2(this, _findRequires, findRequires_fn).call(this, mainFile, cwd);
  const moduleMap = new Map(modules.map((m) => [m.name, m]));
  for (const [_, mod] of moduleMap) {
    if (!mod.content) {
      const fileContent = await fs.promises.readFile(mod.path, "utf-8");
      mod.content = fileContent.split("\n").map((line) => `  ${line}`).join("\n");
      const requiresInMod = await __privateMethod$2(this, _findRequires, findRequires_fn).call(this, mod.content, cwd);
      for (const requirement of requiresInMod) {
        if (!moduleMap.has(requirement.name)) {
          moduleMap.set(requirement.name, requirement);
        }
        mod.dependencies = (mod.dependencies || /* @__PURE__ */ new Set()).add(requirement.name);
      }
    }
  }
  const sortedModules = __privateMethod$2(this, _topologicalSort, topologicalSort_fn).call(this, moduleMap);
  return sortedModules.filter((mod) => mod.content);
};
_findRequires = new WeakSet();
findRequires_fn = async function(data, cwd) {
  const requirePattern = /(?<=(require( *)(\n*)(\()?( *)("|'))).*(?=("|'))/g;
  const requiredModules = (data.match(requirePattern) || []).map(async (mod) => {
    const modPath = await __privateMethod$2(this, _getModulePath, getModulePath_fn).call(this, mod, cwd);
    return modPath ? { name: mod, path: modPath, content: void 0 } : null;
  });
  return (await Promise.all(requiredModules)).filter((m) => !!m);
};

var __accessCheck$1 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$1 = (obj, member, getter) => {
  __accessCheck$1(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$1 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$1 = (obj, member, value, setter) => {
  __accessCheck$1(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod$1 = (obj, member, method) => {
  __accessCheck$1(obj, member, "access private method");
  return method;
};
var _cachedAosDetails, _getAosDetails, getAosDetails_fn, _findProcess, findProcess_fn, _validateCron, validateCron_fn;
class DeploymentsManager {
  constructor() {
    __privateAdd$1(this, _getAosDetails);
    __privateAdd$1(this, _findProcess);
    __privateAdd$1(this, _validateCron);
    __privateAdd$1(this, _cachedAosDetails, null);
  }
  /**
   * Deploys or updates a contract on AO.
   * @param {DeployConfig} deployConfig - Configuration options for the deployment.
   * @returns {Promise<DeployResult>} The result of the deployment.
   */
  async deployContract({ name, wallet, contractPath, tags, cron, module, scheduler, retry, luaPath, configName, processId }) {
    name = name || "default";
    configName = configName || name;
    retry = {
      count: typeof retry?.count === "number" && retry.count >= 0 ? retry.count : 10,
      delay: typeof retry?.delay === "number" && retry.delay >= 0 ? retry.delay : 3e3
    };
    const logger = new Logger(configName);
    const aosDetails = await __privateMethod$1(this, _getAosDetails, getAosDetails_fn).call(this);
    module = isArweaveAddress(module) ? module : aosDetails.module;
    scheduler = isArweaveAddress(scheduler) ? scheduler : aosDetails.scheduler;
    const walletInstance = await Wallet.load(wallet);
    const owner = await walletInstance.getAddress();
    const signer = aoconnect.createDataItemSigner(walletInstance.jwk);
    if (!processId || processId && !isArweaveAddress(processId)) {
      processId = await __privateMethod$1(this, _findProcess, findProcess_fn).call(this, name, owner);
    }
    const isNewProcess = !processId;
    if (!processId) {
      logger.log("Spawning new process...", false, true);
      tags = Array.isArray(tags) ? tags : [];
      tags = [
        { name: "App-Name", value: "aos" },
        { name: "Name", value: name },
        { name: "aos-Version", value: aosDetails.version },
        ...tags
      ];
      if (cron) {
        __privateMethod$1(this, _validateCron, validateCron_fn).call(this, cron);
        tags = [...tags, { name: "Cron-Interval", value: cron }, { name: "Cron-Tag-Action", value: "Cron" }];
      }
      const data = "1984";
      processId = await retryWithDelay(
        () => aoconnect.spawn({ module, signer, tags, data, scheduler }),
        retry.count,
        retry.delay
      );
      await sleep(1e3);
    } else {
      logger.log("Updating existing process...", false, true);
    }
    const loader = new LuaProjectLoader(configName, luaPath);
    const contractSrc = await loader.loadContract(contractPath);
    const messageId = await retryWithDelay(
      async () => aoconnect.message({
        process: processId,
        tags: [{ name: "Action", value: "Eval" }],
        data: contractSrc,
        signer
      }),
      retry.count,
      retry.delay
    );
    const { Output, Error: error } = await retryWithDelay(
      async () => aoconnect.result({
        process: processId,
        message: messageId
      }),
      retry.count,
      retry.delay
    );
    let errorMessage = null;
    if (Output?.data?.output) {
      errorMessage = Output.data.output;
    } else if (error) {
      if (typeof error === "object" && Object.keys(error).length > 0) {
        errorMessage = JSON.stringify(error);
      } else {
        errorMessage = String(error);
      }
    }
    if (errorMessage) {
      throw new Error(errorMessage);
    }
    return { name, processId, messageId, isNewProcess, configName };
  }
  /**
   * Deploys multiple contracts concurrently with specified concurrency limits.
   * @param {DeployConfig[]} deployConfigs - Array of deployment configurations.
   * @param {number} concurrency - Maximum number of deployments to run concurrently. Default is 5.
   * @returns {Promise<PromiseSettledResult<DeployResult>[]>} Array of results for each deployment, either fulfilled or rejected.
   */
  async deployContracts(deployConfigs, concurrency = 5) {
    const limit = pLimit__default(concurrency);
    const promises = deployConfigs.map((config) => limit(() => deployContract(config)));
    const results = await Promise.allSettled(promises);
    return results;
  }
}
_cachedAosDetails = new WeakMap();
_getAosDetails = new WeakSet();
getAosDetails_fn = async function() {
  if (__privateGet$1(this, _cachedAosDetails)) {
    return __privateGet$1(this, _cachedAosDetails);
  }
  const defaultDetails = {
    version: "1.10.22",
    module: "SBNb1qPQ1TDwpD_mboxm2YllmMLXpWw4U8P9Ff8W9vk",
    scheduler: "_GQ33BkPtZrqxA84vM8Zk-N2aO0toNNu_C-l-rawrBA"
  };
  try {
    const response = await fetch("https://raw.githubusercontent.com/permaweb/aos/main/package.json");
    const pkg = await response.json();
    __privateSet$1(this, _cachedAosDetails, {
      version: pkg?.version || defaultDetails.version,
      module: pkg?.aos?.module || defaultDetails.module,
      scheduler: defaultDetails.scheduler
    });
    return __privateGet$1(this, _cachedAosDetails);
  } catch {
    return defaultDetails;
  }
};
_findProcess = new WeakSet();
findProcess_fn = async function(name, owner) {
  const tx = await ardb.appName("aos").search("transactions").from(owner).only("id").tags([
    { name: "Data-Protocol", values: ["ao"] },
    { name: "Type", values: ["Process"] },
    { name: "Name", values: [name] }
  ]).findOne();
  return tx?.id;
};
_validateCron = new WeakSet();
validateCron_fn = function(cron) {
  const cronRegex = /^\d+\-(Second|second|Minute|Minute|Hour|hour|Day|day|Month|month|Year|year|Block|block)s?$/;
  if (!cronRegex.test(cron)) {
    throw new Error("Invalid cron flag!");
  }
};
async function deployContract(deployConfig) {
  const manager = new DeploymentsManager();
  return manager.deployContract(deployConfig);
}
async function deployContracts(deployConfigs, concurrency = 5) {
  const manager = new DeploymentsManager();
  return manager.deployContracts(deployConfigs, concurrency);
}

var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _config, _load, load_fn, _isNonEmptyString, isNonEmptyString_fn, _isString, isString_fn, _validateTags, validateTags_fn, _validateRetry, validateRetry_fn;
const __filename$1 = node_url.fileURLToPath((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.src || new URL('index.cjs', document.baseURI).href)));
const jiti = createJITI__default(__filename$1);
const _ConfigManager = class _ConfigManager {
  constructor(configPath) {
    __privateAdd(this, _load);
    __privateAdd(this, _config, {});
    const loadedConfig = __privateMethod(this, _load, load_fn).call(this, configPath);
    if (_ConfigManager.isValidConfig(loadedConfig)) {
      __privateSet(this, _config, loadedConfig);
    } else {
      throw new Error("Invalid config file loaded.");
    }
  }
  static isValidConfig(config) {
    if (!config || typeof config !== "object" || Object.keys(config).length === 0) {
      return false;
    }
    return Object.values(config).every((deployConfig) => {
      if (!deployConfig || typeof deployConfig !== "object") {
        return false;
      }
      const requiredStringProps = ["contractPath", "name"];
      const optionalStringProps = ["module", "scheduler", "cron", "luaPath", "wallet", "configName", "processId"];
      const hasRequiredStrings = requiredStringProps.every((prop) => __privateMethod(this, _isNonEmptyString, isNonEmptyString_fn).call(this, deployConfig[prop]));
      const hasOptionalStrings = optionalStringProps.every((prop) => !deployConfig[prop] || __privateMethod(this, _isString, isString_fn).call(this, deployConfig[prop]));
      const tagsValid = __privateMethod(this, _validateTags, validateTags_fn).call(this, deployConfig.tags);
      const retryValid = __privateMethod(this, _validateRetry, validateRetry_fn).call(this, deployConfig.retry);
      return hasRequiredStrings && hasOptionalStrings && tagsValid && retryValid;
    });
  }
  getConfig() {
    return __privateGet(this, _config);
  }
  getConfigFromNames(keys) {
    if (keys.length === 0) {
      return __privateGet(this, _config);
    }
    return Object.fromEntries(Object.entries(__privateGet(this, _config)).filter(([key, _]) => keys.includes(key)));
  }
  getDeployConfigs(deploy) {
    const configNames = (deploy ?? "").split(",").map((name) => name.trim()).filter(Boolean);
    const config = this.getConfigFromNames(configNames);
    if (Object.keys(config).length === 0) {
      throw new Error(`Config file doesn't have names from ${deploy}`);
    }
    const deployConfigs = Object.entries(config).map(([name, config2]) => ({ ...config2, configName: name }));
    return deployConfigs;
  }
};
_config = new WeakMap();
_load = new WeakSet();
load_fn = function(configPath) {
  const fullPath = path__default.join(process__default.cwd(), configPath);
  const configs = jiti(fullPath);
  return configs.default ?? configs;
};
_isNonEmptyString = new WeakSet();
isNonEmptyString_fn = function(value) {
  return typeof value === "string" && value.length > 0;
};
_isString = new WeakSet();
isString_fn = function(value) {
  return typeof value === "string";
};
_validateTags = new WeakSet();
validateTags_fn = function(tags) {
  return tags === void 0 || Array.isArray(tags) && tags.length === 0 || Array.isArray(tags) && tags.every(
    (tag) => tag && typeof tag === "object" && __privateMethod(this, _isNonEmptyString, isNonEmptyString_fn).call(this, tag.name) && __privateMethod(this, _isNonEmptyString, isNonEmptyString_fn).call(this, tag.value)
  );
};
_validateRetry = new WeakSet();
validateRetry_fn = function(retry) {
  return retry === void 0 || typeof retry === "object" && (retry.count === void 0 || typeof retry.count === "number" && retry.count >= 0) && (retry.delay === void 0 || typeof retry.delay === "number" && retry.delay >= 0);
};
__privateAdd(_ConfigManager, _isNonEmptyString);
__privateAdd(_ConfigManager, _isString);
__privateAdd(_ConfigManager, _validateTags);
__privateAdd(_ConfigManager, _validateRetry);
let ConfigManager = _ConfigManager;
function defineConfig(config) {
  if (!ConfigManager.isValidConfig(config)) {
    throw new Error("Invalid config file loaded.");
  }
  return config;
}

exports.DeploymentsManager = DeploymentsManager;
exports.defineConfig = defineConfig;
exports.deployContract = deployContract;
exports.deployContracts = deployContracts;
