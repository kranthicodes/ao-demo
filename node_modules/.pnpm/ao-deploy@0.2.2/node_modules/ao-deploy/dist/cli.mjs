#!/usr/bin/env node
import process, { emitWarning } from 'node:process';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import fs, { promises, constants } from 'node:fs';
import chalk from 'chalk';
import { Command } from 'commander';
import { createDataItemSigner, spawn, message, result } from '@permaweb/aoconnect';
import pLimit from 'p-limit';
import os from 'node:os';
import Arweave from 'arweave';
import Ardb from 'ardb';
import { exec } from 'node:child_process';
import util from 'node:util';
import createFileTree from 'pretty-file-tree';
import createJITI from 'jiti';

const arweave = Arweave.init({
  host: "arweave.net",
  port: 443,
  protocol: "https"
});
const ardb = new (Ardb?.default ?? Ardb)(arweave);
function isArweaveAddress(address) {
  return typeof address === "string" && /^[a-z0-9-_]{43}$/i.test(address);
}
async function sleep(delay = 3e3) {
  return new Promise((resolve, _) => setTimeout(resolve, delay));
}
async function retryWithDelay(fn, maxAttempts = 3, delay = 1e3) {
  let attempts = 0;
  const attempt = async () => {
    try {
      return await fn();
    } catch (error) {
      attempts += 1;
      if (attempts < maxAttempts) {
        return new Promise((resolve) => setTimeout(() => resolve(attempt()), delay));
      } else {
        throw error;
      }
    }
  };
  return attempt();
}

var __accessCheck$4 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$4 = (obj, member, getter) => {
  __accessCheck$4(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$4 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$4 = (obj, member, value, setter) => {
  __accessCheck$4(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod$4 = (obj, member, method) => {
  __accessCheck$4(obj, member, "access private method");
  return method;
};
var _jwk, _checkIfWalletLoaded, checkIfWalletLoaded_fn;
const _Wallet = class _Wallet {
  constructor(jwk) {
    __privateAdd$4(this, _checkIfWalletLoaded);
    __privateAdd$4(this, _jwk, void 0);
    __privateSet$4(this, _jwk, jwk);
  }
  /**
   * Check if the passed argument is a valid JSON Web Key (JWK) for Arweave.
   * @param obj - The object to check for JWK validity.
   * @returns {boolean} True if it's a valid Arweave JWK, otherwise false.
   */
  static isJwk(obj) {
    if (typeof obj !== "object") {
      return false;
    }
    const requiredKeys = ["n", "e", "d", "p", "q", "dp", "dq", "qi"];
    return requiredKeys.every((key) => key in obj);
  }
  static async getWallet(jwkOrPath) {
    try {
      if (!jwkOrPath) {
        throw new Error("Wallet not specified");
      }
      if (this.isJwk(jwkOrPath)) {
        return jwkOrPath;
      }
      const jwk = fs.readFileSync(jwkOrPath, "utf8");
      return JSON.parse(jwk);
    } catch (e) {
      if (fs.existsSync(path.resolve(`${os.homedir()}/.aos.json`))) {
        return JSON.parse(fs.readFileSync(path.resolve(`${os.homedir()}/.aos.json`), "utf-8"));
      }
      const wallet = await arweave.wallets.generate();
      fs.writeFileSync(path.resolve(`${os.homedir()}/.aos.json`), JSON.stringify(wallet));
      return wallet;
    }
  }
  static async load(jwkOrPath) {
    const jwk = await this.getWallet(jwkOrPath);
    return new _Wallet(jwk);
  }
  async getAddress() {
    __privateMethod$4(this, _checkIfWalletLoaded, checkIfWalletLoaded_fn).call(this);
    return await arweave.wallets.getAddress(__privateGet$4(this, _jwk));
  }
  get jwk() {
    __privateMethod$4(this, _checkIfWalletLoaded, checkIfWalletLoaded_fn).call(this);
    return __privateGet$4(this, _jwk);
  }
};
_jwk = new WeakMap();
_checkIfWalletLoaded = new WeakSet();
checkIfWalletLoaded_fn = function() {
  if (!__privateGet$4(this, _jwk)) {
    throw new Error("Wallet not loaded yet");
  }
};
let Wallet = _Wallet;

var __accessCheck$3 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$3 = (obj, member, getter) => {
  __accessCheck$3(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$3 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$3 = (obj, member, value, setter) => {
  __accessCheck$3(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod$3 = (obj, member, method) => {
  __accessCheck$3(obj, member, "access private method");
  return method;
};
var _instances, _name, _getInstance, getInstance_fn, _logMessage, logMessage_fn;
const _Logger = class _Logger {
  constructor(name) {
    __privateAdd$3(this, _logMessage);
    __privateAdd$3(this, _name, void 0);
    __privateSet$3(this, _name, name);
  }
  static init(name) {
    return __privateMethod$3(this, _getInstance, getInstance_fn).call(this, name);
  }
  log(message, prefixNewLine = false, suffixNewLine = false) {
    __privateMethod$3(this, _logMessage, logMessage_fn).call(this, `${chalk.blue(`[${__privateGet$3(this, _name)}]`)} ${message}`, prefixNewLine, suffixNewLine);
  }
  success(message, prefixNewLine = false, suffixNewLine = false) {
    __privateMethod$3(this, _logMessage, logMessage_fn).call(this, `${chalk.blue(`[${__privateGet$3(this, _name)}]`)} ${chalk.green(message)}`, prefixNewLine, suffixNewLine);
  }
  error(message, prefixNewLine = false, suffixNewLine = false) {
    __privateMethod$3(this, _logMessage, logMessage_fn).call(this, `${chalk.red(`[${__privateGet$3(this, _name)}]`)} ${chalk.red(message)}`, prefixNewLine, suffixNewLine);
  }
  static log(name, message, prefixNewLine = false, suffixNewLine = false) {
    __privateMethod$3(this, _getInstance, getInstance_fn).call(this, name).log(message, prefixNewLine, suffixNewLine);
  }
  static success(name, message, prefixNewLine = false, suffixNewLine = false) {
    __privateMethod$3(this, _getInstance, getInstance_fn).call(this, name).success(message, prefixNewLine, suffixNewLine);
  }
  static error(name, message, prefixNewLine = false, suffixNewLine = false) {
    __privateMethod$3(this, _getInstance, getInstance_fn).call(this, name).error(message, prefixNewLine, suffixNewLine);
  }
};
_instances = new WeakMap();
_name = new WeakMap();
_getInstance = new WeakSet();
getInstance_fn = function(name) {
  if (!__privateGet$3(_Logger, _instances).has(name)) {
    __privateGet$3(_Logger, _instances).set(name, new _Logger(name));
  }
  return __privateGet$3(_Logger, _instances).get(name);
};
_logMessage = new WeakSet();
logMessage_fn = function(message, prefixNewLine, suffixNewLine) {
  const prefix = prefixNewLine ? "\n" : "";
  const suffix = suffixNewLine ? "\n" : "";
  console.log(`${prefix}${message}${suffix}`);
};
__privateAdd$3(_Logger, _getInstance);
__privateAdd$3(_Logger, _instances, /* @__PURE__ */ new Map());
let Logger = _Logger;

var __accessCheck$2 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$2 = (obj, member, getter) => {
  __accessCheck$2(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$2 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$2 = (obj, member, value, setter) => {
  __accessCheck$2(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod$2 = (obj, member, method) => {
  __accessCheck$2(obj, member, "access private method");
  return method;
};
var _luaPath, _logger, _fileExists, fileExists_fn, _getModulePath, getModulePath_fn, _createExecutableFromProject, createExecutableFromProject_fn, _topologicalSort, topologicalSort_fn, _createProjectStructure, createProjectStructure_fn, _findRequires, findRequires_fn;
const execAsync = util.promisify(exec);
class LuaProjectLoader {
  constructor(name, luaPath) {
    __privateAdd$2(this, _fileExists);
    __privateAdd$2(this, _getModulePath);
    __privateAdd$2(this, _createExecutableFromProject);
    __privateAdd$2(this, _topologicalSort);
    __privateAdd$2(this, _createProjectStructure);
    __privateAdd$2(this, _findRequires);
    __privateAdd$2(this, _luaPath, void 0);
    __privateAdd$2(this, _logger, void 0);
    __privateSet$2(this, _luaPath, luaPath || "");
    __privateSet$2(this, _logger, Logger.init(name));
  }
  async loadContract(contractPath) {
    if (/\.lua$/.test(contractPath)) {
      let filePath = contractPath;
      if (!path.isAbsolute(filePath)) {
        filePath = path.resolve(path.join(process.cwd(), contractPath));
      }
      if (!await __privateMethod$2(this, _fileExists, fileExists_fn).call(this, filePath)) {
        throw new Error(chalk.red(`${filePath} file not found.`));
      }
      __privateGet$2(this, _logger).log(`Deploying: ${contractPath}`, false, true);
      let line = await promises.readFile(filePath, "utf-8");
      __privateGet$2(this, _logger).log(`Parsing contract structure...`, false, true);
      const projectStructure = await __privateMethod$2(this, _createProjectStructure, createProjectStructure_fn).call(this, line, path.dirname(filePath));
      if (projectStructure.length > 0) {
        line = `${__privateMethod$2(this, _createExecutableFromProject, createExecutableFromProject_fn).call(this, projectStructure)}

${line}`;
        __privateGet$2(this, _logger).log(chalk.yellow(`The following files will be deployed:`), false, true);
        console.log(chalk.dim(createFileTree([...projectStructure.map((m) => m.path), `${filePath} ${chalk.reset(chalk.bgGreen(" MAIN "))}`])));
        console.log("");
      }
      return line.trim();
    } else {
      throw new Error(chalk.red("It requires a *.lua file"));
    }
  }
}
_luaPath = new WeakMap();
_logger = new WeakMap();
_fileExists = new WeakSet();
fileExists_fn = async function(path2) {
  try {
    await promises.access(path2, constants.F_OK | constants.R_OK);
    return true;
  } catch {
    return false;
  }
};
_getModulePath = new WeakSet();
getModulePath_fn = async function(module, cwd) {
  try {
    const modPath = path.join(cwd, `${module.replace(/\./g, "/")}.lua`);
    if (await __privateMethod$2(this, _fileExists, fileExists_fn).call(this, modPath)) {
      return modPath;
    }
    const luaCode = `print(package.searchpath('${module}', package.path .. ';' .. '${__privateGet$2(this, _luaPath)}'))`;
    const command = `lua -e "${luaCode}"`;
    const { stdout, stderr } = await execAsync(command);
    if (stderr) {
      return;
    }
    if (stdout) {
      const potentialPath = stdout.trim();
      if (await __privateMethod$2(this, _fileExists, fileExists_fn).call(this, potentialPath)) {
        return potentialPath;
      }
    }
  } catch (error) {
  }
};
_createExecutableFromProject = new WeakSet();
createExecutableFromProject_fn = function(project) {
  const getModFnName = (name) => name.replace(/\./g, "_").replace(/^_/, "");
  const contents = [];
  for (const mod of project) {
    const existing = contents.find((m) => m.path === mod.path);
    const moduleContent = !existing && `-- module: "${mod.name}"
local function _loaded_mod_${getModFnName(mod.name)}()
${mod.content}
end
` || "";
    const requireMapper = `
_G.package.loaded["${mod.name}"] = _loaded_mod_${getModFnName(existing?.name || mod.name)}()`;
    contents.push({
      name: mod.name,
      path: mod.path,
      code: moduleContent + requireMapper
    });
  }
  return contents.reduce((acc, con) => `${acc}

${con.code}`, "");
};
_topologicalSort = new WeakSet();
topologicalSort_fn = function(moduleMap) {
  const visited = /* @__PURE__ */ new Set();
  const result = [];
  function visit(modName) {
    if (visited.has(modName)) {
      return;
    }
    const mod = moduleMap.get(modName);
    if (!mod) {
      throw new Error(`Module ${modName} is not found in the module map.`);
    }
    visited.add(modName);
    mod.dependencies?.forEach((depName) => visit(depName));
    result.push(mod);
  }
  moduleMap.forEach((_, modName) => visit(modName));
  return result;
};
_createProjectStructure = new WeakSet();
createProjectStructure_fn = async function(mainFile, cwd) {
  const modules = await __privateMethod$2(this, _findRequires, findRequires_fn).call(this, mainFile, cwd);
  const moduleMap = new Map(modules.map((m) => [m.name, m]));
  for (const [_, mod] of moduleMap) {
    if (!mod.content) {
      const fileContent = await promises.readFile(mod.path, "utf-8");
      mod.content = fileContent.split("\n").map((line) => `  ${line}`).join("\n");
      const requiresInMod = await __privateMethod$2(this, _findRequires, findRequires_fn).call(this, mod.content, cwd);
      for (const requirement of requiresInMod) {
        if (!moduleMap.has(requirement.name)) {
          moduleMap.set(requirement.name, requirement);
        }
        mod.dependencies = (mod.dependencies || /* @__PURE__ */ new Set()).add(requirement.name);
      }
    }
  }
  const sortedModules = __privateMethod$2(this, _topologicalSort, topologicalSort_fn).call(this, moduleMap);
  return sortedModules.filter((mod) => mod.content);
};
_findRequires = new WeakSet();
findRequires_fn = async function(data, cwd) {
  const requirePattern = /(?<=(require( *)(\n*)(\()?( *)("|'))).*(?=("|'))/g;
  const requiredModules = (data.match(requirePattern) || []).map(async (mod) => {
    const modPath = await __privateMethod$2(this, _getModulePath, getModulePath_fn).call(this, mod, cwd);
    return modPath ? { name: mod, path: modPath, content: void 0 } : null;
  });
  return (await Promise.all(requiredModules)).filter((m) => !!m);
};

var __accessCheck$1 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$1 = (obj, member, getter) => {
  __accessCheck$1(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$1 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$1 = (obj, member, value, setter) => {
  __accessCheck$1(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod$1 = (obj, member, method) => {
  __accessCheck$1(obj, member, "access private method");
  return method;
};
var _cachedAosDetails, _getAosDetails, getAosDetails_fn, _findProcess, findProcess_fn, _validateCron, validateCron_fn;
class DeploymentsManager {
  constructor() {
    __privateAdd$1(this, _getAosDetails);
    __privateAdd$1(this, _findProcess);
    __privateAdd$1(this, _validateCron);
    __privateAdd$1(this, _cachedAosDetails, null);
  }
  /**
   * Deploys or updates a contract on AO.
   * @param {DeployConfig} deployConfig - Configuration options for the deployment.
   * @returns {Promise<DeployResult>} The result of the deployment.
   */
  async deployContract({ name, wallet, contractPath, tags, cron, module, scheduler, retry, luaPath, configName, processId }) {
    name = name || "default";
    configName = configName || name;
    retry = {
      count: typeof retry?.count === "number" && retry.count >= 0 ? retry.count : 10,
      delay: typeof retry?.delay === "number" && retry.delay >= 0 ? retry.delay : 3e3
    };
    const logger = new Logger(configName);
    const aosDetails = await __privateMethod$1(this, _getAosDetails, getAosDetails_fn).call(this);
    module = isArweaveAddress(module) ? module : aosDetails.module;
    scheduler = isArweaveAddress(scheduler) ? scheduler : aosDetails.scheduler;
    const walletInstance = await Wallet.load(wallet);
    const owner = await walletInstance.getAddress();
    const signer = createDataItemSigner(walletInstance.jwk);
    if (!processId || processId && !isArweaveAddress(processId)) {
      processId = await __privateMethod$1(this, _findProcess, findProcess_fn).call(this, name, owner);
    }
    const isNewProcess = !processId;
    if (!processId) {
      logger.log("Spawning new process...", false, true);
      tags = Array.isArray(tags) ? tags : [];
      tags = [
        { name: "App-Name", value: "aos" },
        { name: "Name", value: name },
        { name: "aos-Version", value: aosDetails.version },
        ...tags
      ];
      if (cron) {
        __privateMethod$1(this, _validateCron, validateCron_fn).call(this, cron);
        tags = [...tags, { name: "Cron-Interval", value: cron }, { name: "Cron-Tag-Action", value: "Cron" }];
      }
      const data = "1984";
      processId = await retryWithDelay(
        () => spawn({ module, signer, tags, data, scheduler }),
        retry.count,
        retry.delay
      );
      await sleep(1e3);
    } else {
      logger.log("Updating existing process...", false, true);
    }
    const loader = new LuaProjectLoader(configName, luaPath);
    const contractSrc = await loader.loadContract(contractPath);
    const messageId = await retryWithDelay(
      async () => message({
        process: processId,
        tags: [{ name: "Action", value: "Eval" }],
        data: contractSrc,
        signer
      }),
      retry.count,
      retry.delay
    );
    const { Output, Error: error } = await retryWithDelay(
      async () => result({
        process: processId,
        message: messageId
      }),
      retry.count,
      retry.delay
    );
    let errorMessage = null;
    if (Output?.data?.output) {
      errorMessage = Output.data.output;
    } else if (error) {
      if (typeof error === "object" && Object.keys(error).length > 0) {
        errorMessage = JSON.stringify(error);
      } else {
        errorMessage = String(error);
      }
    }
    if (errorMessage) {
      throw new Error(errorMessage);
    }
    return { name, processId, messageId, isNewProcess, configName };
  }
  /**
   * Deploys multiple contracts concurrently with specified concurrency limits.
   * @param {DeployConfig[]} deployConfigs - Array of deployment configurations.
   * @param {number} concurrency - Maximum number of deployments to run concurrently. Default is 5.
   * @returns {Promise<PromiseSettledResult<DeployResult>[]>} Array of results for each deployment, either fulfilled or rejected.
   */
  async deployContracts(deployConfigs, concurrency = 5) {
    const limit = pLimit(concurrency);
    const promises = deployConfigs.map((config) => limit(() => deployContract(config)));
    const results = await Promise.allSettled(promises);
    return results;
  }
}
_cachedAosDetails = new WeakMap();
_getAosDetails = new WeakSet();
getAosDetails_fn = async function() {
  if (__privateGet$1(this, _cachedAosDetails)) {
    return __privateGet$1(this, _cachedAosDetails);
  }
  const defaultDetails = {
    version: "1.10.22",
    module: "SBNb1qPQ1TDwpD_mboxm2YllmMLXpWw4U8P9Ff8W9vk",
    scheduler: "_GQ33BkPtZrqxA84vM8Zk-N2aO0toNNu_C-l-rawrBA"
  };
  try {
    const response = await fetch("https://raw.githubusercontent.com/permaweb/aos/main/package.json");
    const pkg = await response.json();
    __privateSet$1(this, _cachedAosDetails, {
      version: pkg?.version || defaultDetails.version,
      module: pkg?.aos?.module || defaultDetails.module,
      scheduler: defaultDetails.scheduler
    });
    return __privateGet$1(this, _cachedAosDetails);
  } catch {
    return defaultDetails;
  }
};
_findProcess = new WeakSet();
findProcess_fn = async function(name, owner) {
  const tx = await ardb.appName("aos").search("transactions").from(owner).only("id").tags([
    { name: "Data-Protocol", values: ["ao"] },
    { name: "Type", values: ["Process"] },
    { name: "Name", values: [name] }
  ]).findOne();
  return tx?.id;
};
_validateCron = new WeakSet();
validateCron_fn = function(cron) {
  const cronRegex = /^\d+\-(Second|second|Minute|Minute|Hour|hour|Day|day|Month|month|Year|year|Block|block)s?$/;
  if (!cronRegex.test(cron)) {
    throw new Error("Invalid cron flag!");
  }
};
async function deployContract(deployConfig) {
  const manager = new DeploymentsManager();
  return manager.deployContract(deployConfig);
}
async function deployContracts(deployConfigs, concurrency = 5) {
  const manager = new DeploymentsManager();
  return manager.deployContracts(deployConfigs, concurrency);
}

var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _config, _load, load_fn, _isNonEmptyString, isNonEmptyString_fn, _isString, isString_fn, _validateTags, validateTags_fn, _validateRetry, validateRetry_fn;
const __filename = fileURLToPath(import.meta.url);
const jiti = createJITI(__filename);
const _ConfigManager = class _ConfigManager {
  constructor(configPath) {
    __privateAdd(this, _load);
    __privateAdd(this, _config, {});
    const loadedConfig = __privateMethod(this, _load, load_fn).call(this, configPath);
    if (_ConfigManager.isValidConfig(loadedConfig)) {
      __privateSet(this, _config, loadedConfig);
    } else {
      throw new Error("Invalid config file loaded.");
    }
  }
  static isValidConfig(config) {
    if (!config || typeof config !== "object" || Object.keys(config).length === 0) {
      return false;
    }
    return Object.values(config).every((deployConfig) => {
      if (!deployConfig || typeof deployConfig !== "object") {
        return false;
      }
      const requiredStringProps = ["contractPath", "name"];
      const optionalStringProps = ["module", "scheduler", "cron", "luaPath", "wallet", "configName", "processId"];
      const hasRequiredStrings = requiredStringProps.every((prop) => __privateMethod(this, _isNonEmptyString, isNonEmptyString_fn).call(this, deployConfig[prop]));
      const hasOptionalStrings = optionalStringProps.every((prop) => !deployConfig[prop] || __privateMethod(this, _isString, isString_fn).call(this, deployConfig[prop]));
      const tagsValid = __privateMethod(this, _validateTags, validateTags_fn).call(this, deployConfig.tags);
      const retryValid = __privateMethod(this, _validateRetry, validateRetry_fn).call(this, deployConfig.retry);
      return hasRequiredStrings && hasOptionalStrings && tagsValid && retryValid;
    });
  }
  getConfig() {
    return __privateGet(this, _config);
  }
  getConfigFromNames(keys) {
    if (keys.length === 0) {
      return __privateGet(this, _config);
    }
    return Object.fromEntries(Object.entries(__privateGet(this, _config)).filter(([key, _]) => keys.includes(key)));
  }
  getDeployConfigs(deploy) {
    const configNames = (deploy ?? "").split(",").map((name) => name.trim()).filter(Boolean);
    const config = this.getConfigFromNames(configNames);
    if (Object.keys(config).length === 0) {
      throw new Error(`Config file doesn't have names from ${deploy}`);
    }
    const deployConfigs = Object.entries(config).map(([name, config2]) => ({ ...config2, configName: name }));
    return deployConfigs;
  }
};
_config = new WeakMap();
_load = new WeakSet();
load_fn = function(configPath) {
  const fullPath = path.join(process.cwd(), configPath);
  const configs = jiti(fullPath);
  return configs.default ?? configs;
};
_isNonEmptyString = new WeakSet();
isNonEmptyString_fn = function(value) {
  return typeof value === "string" && value.length > 0;
};
_isString = new WeakSet();
isString_fn = function(value) {
  return typeof value === "string";
};
_validateTags = new WeakSet();
validateTags_fn = function(tags) {
  return tags === void 0 || Array.isArray(tags) && tags.length === 0 || Array.isArray(tags) && tags.every(
    (tag) => tag && typeof tag === "object" && __privateMethod(this, _isNonEmptyString, isNonEmptyString_fn).call(this, tag.name) && __privateMethod(this, _isNonEmptyString, isNonEmptyString_fn).call(this, tag.value)
  );
};
_validateRetry = new WeakSet();
validateRetry_fn = function(retry) {
  return retry === void 0 || typeof retry === "object" && (retry.count === void 0 || typeof retry.count === "number" && retry.count >= 0) && (retry.delay === void 0 || typeof retry.delay === "number" && retry.delay >= 0);
};
__privateAdd(_ConfigManager, _isNonEmptyString);
__privateAdd(_ConfigManager, _isString);
__privateAdd(_ConfigManager, _validateTags);
__privateAdd(_ConfigManager, _validateRetry);
let ConfigManager = _ConfigManager;

const PKG_ROOT = path.join(path.dirname(fileURLToPath(import.meta.url)), "../");
process.emitWarning = (warning, ...args) => {
  if (args[0] === "ExperimentalWarning") {
    return;
  }
  if (args[0] && typeof args[0] === "object" && args[0].type === "ExperimentalWarning") {
    return;
  }
  return emitWarning(warning, ...args);
};
function getPackageJson() {
  const packageJsonPath = path.join(PKG_ROOT, "package.json");
  const packageJson2 = JSON.parse(fs.readFileSync(packageJsonPath).toString());
  return packageJson2;
}
function parseToInt(value, defaultValue) {
  const parsedValue = Number.parseInt(value);
  if (Number.isNaN(parsedValue)) {
    return defaultValue;
  }
  return parsedValue;
}
function logDeploymentDetails(result) {
  const { messageId, processId, isNewProcess, configName } = result;
  const processUrl = chalk.green(`https://ao_marton.g8way.io/#/process/${processId}`);
  const messageUrl = chalk.green(`${processUrl}/${messageId}`);
  const logger = Logger.init(configName);
  console.log("");
  if (isNewProcess) {
    logger.log(`Deployed Process: ${processUrl}`);
  }
  logger.log(`Deployment Message: ${messageUrl}`);
}
const program = new Command();
const packageJson = getPackageJson();
program.name(packageJson.name).description("Deploy AO contracts using a CLI.").version(packageJson.version).argument("<contractOrConfigPath>", "Path to the main contract file or deployment configuration.").option("-n, --name [name]", "Specify the process name.", "default").option("-w, --wallet [wallet]", "Path to the wallet JWK file.").option("-l, --lua-path [luaPath]", "Specify the Lua modules path seperated by semicolon.").option("-d, --deploy [deploy]", "List of deployment configuration names, separated by commas.").option("-s, --scheduler [scheduler]", "Scheduler to be used for the process.", "_GQ33BkPtZrqxA84vM8Zk-N2aO0toNNu_C-l-rawrBA").option("-m, --module [module]", "Module source for spawning the process.").option("-c, --cron [interval]", "Cron interval for the process (e.g. 1-minute, 5-minutes).").option("-t, --tags [tags...]", "Additional tags for spawning the process.").option("-p, --process-id [processId]", "Specify process Id of an existing process.").option("--concurrency [limit]", "Concurrency limit for deploying multiple processes.", "5").option("--retry-count [count]", "Number of retries for deploying contract.", "10").option("--retry-delay [delay]", "Delay between retries in milliseconds.", "3000");
program.parse(process.argv);
const options = program.opts();
const contractOrConfigPath = program.args[0];
(async () => {
  try {
    Logger.log(packageJson.name, "Deploying...", false, true);
    if (contractOrConfigPath.endsWith(".lua")) {
      const tags = Array.isArray(options.tags) ? options.tags.reduce((accumulator, tag) => {
        if (tag && tag.includes(":")) {
          const [name, value] = tag.split(":");
          accumulator.push({ name, value });
        }
        return accumulator;
      }, []) : [];
      const result = await deployContract(
        {
          name: options.name,
          wallet: options.wallet,
          contractPath: contractOrConfigPath,
          scheduler: options.scheduler,
          module: options.module,
          cron: options.cron,
          tags,
          retry: {
            count: parseToInt(options.retryCount, 10),
            delay: parseToInt(options.retryDelay, 3e3)
          },
          luaPath: options.luaPath,
          configName: options.name,
          processId: options.processId
        }
      );
      logDeploymentDetails(result);
    } else {
      const configManager = new ConfigManager(contractOrConfigPath);
      const deployConfigs = configManager.getDeployConfigs(options.deploy);
      const concurrency = parseToInt(options.concurrency, 5);
      const results = await deployContracts(deployConfigs, concurrency);
      results.forEach((result, idx) => {
        const configName = deployConfigs[idx].configName;
        if (result.status === "fulfilled") {
          logDeploymentDetails(result.value);
        } else {
          Logger.error(configName, "Failed to deploy contract!", true);
          Logger.error(configName, result.reason);
        }
      });
      const totalCount = results.length;
      const successCount = results.filter((r) => r.status === "fulfilled").length;
      Logger.log(packageJson.name, `Deployment Status: ${chalk.green(`${successCount}/${totalCount}`)} successful deployments.`, true);
    }
  } catch (error) {
    const logger = Logger.init(packageJson.name);
    logger.error(`Deployment failed!`, true);
    logger.error(error?.message ?? "Failed to deploy contract!");
    process.exit(1);
  }
})();
